dialect "java"

import org.optaplanner.core.api.score.buildin.hardsoftlong.HardSoftLongScoreHolder;
import uk.ac.diamond.ss.domain.Allocation;
import uk.ac.diamond.ss.domain.Person;
import uk.ac.diamond.ss.domain.Facility;
import uk.ac.diamond.ss.domain.in.WeightsReader;
import org.optaplanner.core.api.score.constraint.primint.IntConstraintMatch;

global HardSoftLongScoreHolder scoreHolder;

//comment on the variables

rule "groupSizeSoft"
    when
    	Allocation($aid : ID, shift != null, $ashiftID : shift.ID)
    	$total : Number() from accumulate(
    		$a : Allocation(ID> $aid, shift != null, shift.ID == $ashiftID), 
    		count($a)
    	)
    then
    int groupSoft = WeightsReader.GROUP_SIZE_SOFT;
    scoreHolder.addSoftConstraintMatch(kcontext, -groupSoft*($total.intValue() * $total.intValue()));
end

rule "groupSizeHard1_6"
 when
 		Facility($facility_name : name)
    	$total : Number(intValue < 1) from accumulate(
    		$a : Allocation(shift != null, shift.facility.name ==  $facility_name), 
    		count($a)
    	)
    then
    scoreHolder.addHardConstraintMatch(kcontext, $total.intValue()-1);
end

rule "groupSizeHard"
    when
    	Allocation($aid : ID, shift != null, $ashiftID : shift.ID, $studentsNumber : shift.getStudentsPerShift())
    	$total : Number(intValue > $studentsNumber) from accumulate(
    		$a : Allocation(ID >= $aid, shift != null, shift.ID == $ashiftID), 
    		count($a)
    	)
    then
   int groupHard = WeightsReader.GROUP_SIZE_HARD;
    scoreHolder.addHardConstraintMatch(kcontext, -groupHard*$total.intValue());
end

rule "noOverlappingAllocationsHard"
   when
  	 Allocation($aid : ID, shift != null, $ashift : shift, person != null, $aPersonID : person.ID)
     Allocation(ID > $aid, shift != null, shift.checkOverlap($ashift), person.ID == $aPersonID )
    then
    int noOverlapping = WeightsReader.NO_OVERLAPPING;
    scoreHolder.addHardConstraintMatch(kcontext, - noOverlapping);
end

rule "noSimilarSesssionsHard"
    when
    	Allocation($aid : ID, shift != null,  $ashift : shift, person != null, $aPersonID : person.ID)
    	Allocation(ID > $aid, shift != null, shift.getSimilar($ashift), person.ID == $aPersonID )
    then
    int noSimilar = WeightsReader.NO_SIMILOAR;
    scoreHolder.addHardConstraintMatch(kcontext, -noSimilar);
end

rule "correlationSoft"
    when
    	$a1:Allocation($aid : ID, shift != null, $ashift : shift, person != null, $aPersonID : person.ID)
    	$a2:Allocation(ID > $aid, shift != null, shift.getCorrelated($ashift)!=0, person.ID == $aPersonID )
    then
    int correlation = WeightsReader.CORRELATION;
    scoreHolder.addSoftConstraintMatch(kcontext, -correlation*$a2.getShift().getCorrelated($a1.getShift()));
end

rule "longExperimentsPairsHard"
 	when
 	Allocation($aid : ID, shift != null, $apair: shift.pair, $apair!=null, person != null, $aPersonID : person.ID)
 	$total : Number(intValue < 2) from accumulate(
 		$a:  Allocation(ID != $aid, shift != null, person != null, shift.ID == $apair.ID, person.ID == $aPersonID),
 		count($a)
 		)
 	then
 	int longExperimants = WeightsReader.LONG_EXPERIMANTS;
   	scoreHolder.addHardConstraintMatch(kcontext, longExperimants*($total.intValue()-1));
end

rule "preferencesSoft"
when
   Person($aPersonID : ID, $totalPreference : getSumPreference())
   	$totalPreferences : Number() from accumulate(
    		Allocation(shift != null, person != null, person.ID == $aPersonID, $preference: person.checkPreference(shift)),
    		sum($preference)
    	)
then
 int pref = WeightsReader.PREFERENCES;
 scoreHolder.addSoftConstraintMatch(kcontext, pref * (-$totalPreference + $totalPreferences.intValue()));
end

rule "firstPreferencesHard"
 	when
 	Person($aPersonID : ID)	
 	$total : Number(intValue<2) from accumulate(
 		$a:  Allocation(shift != null, person != null, person.ID == $aPersonID, person.isFirstOrSecondPreference(shift)),
 		count($a)
 		)
 	then
   	scoreHolder.addHardConstraintMatch(kcontext, ($total.intValue()-1));
end
